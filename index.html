<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoCAD Pro - An√°lisis Geoespacial</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.0.7/dist-browser/geotiff.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 40px;
            text-align: center;
        }

        .header h1 {
            font-size: 42px;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .header p {
            font-size: 18px;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 0;
            min-height: 600px;
        }

        .sidebar {
            background: #f8f9fa;
            padding: 30px;
            border-right: 2px solid #e0e0e0;
            overflow-y: auto;
            max-height: calc(100vh - 200px);
        }

        .content-area {
            padding: 30px;
            overflow-y: auto;
            max-height: calc(100vh - 200px);
        }

        .section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .file-upload {
            border: 3px dashed #3498db;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #f8f9fa;
        }

        .file-upload:hover {
            border-color: #2980b9;
            background: #e8f4f8;
        }

        .file-upload input {
            display: none;
        }

        .file-upload-label {
            cursor: pointer;
            color: #3498db;
            font-weight: 600;
        }

        .btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            width: 100%;
            margin-top: 10px;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }

        .btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60, #229954);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }

        .input-group {
            margin: 15px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            color: #2c3e50;
            font-weight: 600;
            font-size: 14px;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #dce1e8;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #3498db;
        }

        .result-card {
            background: linear-gradient(135deg, #f8f9fa, #ffffff);
            border-left: 4px solid #3498db;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .result-card h4 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
            text-align: center;
        }

        .stat-box .value {
            font-size: 24px;
            font-weight: bold;
            color: #3498db;
            margin: 5px 0;
        }

        .stat-box .label {
            font-size: 12px;
            color: #7f8c8d;
            text-transform: uppercase;
        }

        #map {
            height: 500px;
            border-radius: 10px;
            margin: 20px 0;
        }

        #chart3d {
            height: 600px;
            border-radius: 10px;
            background: white;
            margin: 20px 0;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 500;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 4px solid #17a2b8;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border-left: 4px solid #28a745;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border-left: 4px solid #dc3545;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .file-info {
            background: #e8f4f8;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 13px;
            color: #2c3e50;
        }

        .download-section {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .download-btn {
            flex: 1;
            min-width: 150px;
        }

        .progress-container {
            width: 100%;
            background-color: #f1f1f1;
            border-radius: 5px;
            margin: 10px 0;
            display: none;
        }

        .progress-bar {
            width: 0%;
            height: 20px;
            background-color: #4CAF50;
            border-radius: 5px;
            text-align: center;
            line-height: 20px;
            color: white;
            transition: width 0.3s;
        }

        .export-notes {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 6px;
            margin-top: 15px;
            font-size: 13px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                border-right: none;
                border-bottom: 2px solid #e0e0e0;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåç GeoCAD Pro</h1>
            <p>Plataforma Integral de An√°lisis Geoespacial</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="section">
                    <h3>üìÅ Cargar Datos</h3>
                    <div class="file-upload" onclick="document.getElementById('fileInput').click()">
                        <input type="file" id="fileInput" accept=".tif,.tiff,.asc,.xyz,.csv,.txt,.kml,.kmz,.geojson,.gpx" multiple>
                        <label class="file-upload-label">
                            üì§ Arrastra archivos o haz clic aqu√≠<br>
                            <small style="color: #7f8c8d;">DEM, XYZ, CSV, KML, KMZ, GeoJSON, GPX</small>
                        </label>
                    </div>
                    <div id="fileInfo" class="file-info" style="display: none;"></div>
                    <div class="progress-container" id="progressContainer">
                        <div class="progress-bar" id="progressBar">0%</div>
                    </div>
                </div>

                <div class="section">
                    <h3>‚öôÔ∏è Configuraci√≥n</h3>
                    
                    <div class="input-group">
                        <label>Tipo de Procesamiento:</label>
                        <select id="processType">
                            <option value="dem">DEM Directo</option>
                            <option value="points">Puntos a DEM</option>
                            <option value="kml">KML/KMZ a Superficie</option>
                            <option value="gpx">GPX a Superficie</option>
                        </select>
                    </div>

                    <div class="input-group" id="resolutionGroup" style="display: none;">
                        <label>Resoluci√≥n (p√≠xeles):</label>
                        <input type="number" id="resolution" value="100" min="50" max="500">
                    </div>

                    <div class="input-group" id="interpolationGroup" style="display: none;">
                        <label>M√©todo de Interpolaci√≥n:</label>
                        <select id="interpolation">
                            <option value="cubic">C√∫bica</option>
                            <option value="linear">Lineal</option>
                            <option value="nearest">Vecino m√°s cercano</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label>Reducci√≥n de resoluci√≥n:</label>
                        <select id="downsampling">
                            <option value="1">Sin reducci√≥n</option>
                            <option value="2">2x (recomendado para archivos grandes)</option>
                            <option value="4">4x (archivos muy grandes)</option>
                            <option value="8">8x (archivos enormes)</option>
                        </select>
                    </div>

                    <button class="btn" onclick="processData()" id="processBtn" disabled>
                        üöÄ Procesar Datos
                    </button>
                </div>

                <div class="section">
                    <h3>üìä An√°lisis</h3>
                    
                    <div class="input-group">
                        <label>Intervalo Curvas (m):</label>
                        <input type="number" id="contourInterval" value="10" min="1" max="100">
                    </div>

                    <button class="btn btn-success" onclick="generateContours()" id="contourBtn" disabled>
                        üó∫Ô∏è Generar Curvas de Nivel
                    </button>

                    <button class="btn btn-success" onclick="calculateSlope()" id="slopeBtn" disabled>
                        üìê Calcular Pendiente
                    </button>

                    <button class="btn btn-success" onclick="generate3D()" id="3dBtn" disabled>
                        üîç Vista 3D
                    </button>

                    <div class="input-group" style="margin-top: 15px;">
                        <label>Factor Exageraci√≥n 3D:</label>
                        <input type="number" id="exaggeration" value="2" min="1" max="10" step="0.5">
                    </div>
                </div>

                <div class="section">
                    <h3>üíæ Exportar</h3>
                    <div class="download-section">
                        <button class="btn btn-warning download-btn" onclick="exportGeoTIFF()" id="exportBtn" disabled>
                            üì• GeoTIFF
                        </button>
                        <button class="btn btn-warning download-btn" onclick="exportContours()" id="exportContoursBtn" disabled>
                            üì• Curvas (DXF)
                        </button>
                        <button class="btn btn-warning download-btn" onclick="exportContoursJSON()" id="exportContoursJSONBtn" disabled>
                            üì• Curvas (JSON)
                        </button>
                        <button class="btn btn-warning download-btn" onclick="exportGPX()" id="exportGPXBtn" disabled>
                            üì• GPX
                        </button>
                    </div>
                    <div class="export-notes">
                        <strong>Notas para AutoCAD/Civil 3D:</strong>
                        <ul style="margin: 8px 0 0 15px;">
                            <li>Las curvas se exportan con elevaci√≥n en el atributo Z</li>
                            <li>Curvas maestras (cada 50m) en capa "CURVAS_MAYORES"</li>
                            <li>Curvas intermedias en capa "CURVAS_MENORES"</li>
                            <li>Listo para crear superficie con herramientas de Civil 3D</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="content-area">
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p style="margin-top: 15px; color: #2c3e50;">Procesando...</p>
                </div>

                <div id="results"></div>
                <div id="map" style="display: none;"></div>
                <div id="chart3d" style="display: none;"></div>
                <div id="canvasArea"></div>
            </div>
        </div>
    </div>

    <script>
        let demData = null;
        let pointsData = null;
        let contoursData = null;
        let slopeData = null;
        let aspectData = null;
        let map = null;

        // Inicializaci√≥n cuando el documento est√° listo
        document.addEventListener('DOMContentLoaded', function() {
            // Configurar event listeners
            document.getElementById('fileInput').addEventListener('change', handleFileSelect);
            document.getElementById('processType').addEventListener('change', function() {
                const isPoints = this.value === 'points' || this.value === 'kml' || this.value === 'gpx';
                document.getElementById('resolutionGroup').style.display = isPoints ? 'block' : 'none';
                document.getElementById('interpolationGroup').style.display = isPoints ? 'block' : 'none';
            });

            // Configurar drag and drop
            const container = document.querySelector('.file-upload');
            
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                container.style.borderColor = '#2980b9';
                container.style.background = '#e8f4f8';
            });

            container.addEventListener('dragleave', (e) => {
                e.preventDefault();
                container.style.borderColor = '#3498db';
                container.style.background = '#f8f9fa';
            });

            container.addEventListener('drop', (e) => {
                e.preventDefault();
                container.style.borderColor = '#3498db';
                container.style.background = '#f8f9fa';
                
                const files = e.dataTransfer.files;
                document.getElementById('fileInput').files = files;
                handleFileSelect({ target: { files } });
            });

            // Mostrar mensaje de bienvenida
            showWelcomeMessage();
        });

        function showWelcomeMessage() {
            const welcomeHTML = `
                <div class="alert alert-info">
                    <h4 style="margin-bottom: 10px;">üëã Bienvenido a GeoCAD Pro</h4>
                    <p style="margin: 5px 0;"><strong>Formatos soportados:</strong></p>
                    <ul style="margin: 10px 0 10px 20px;">
                        <li><strong>DEM:</strong> GeoTIFF (.tif, .tiff), ASCII Grid (.asc)</li>
                        <li><strong>Puntos:</strong> XYZ (.xyz), CSV (.csv, .txt)</li>
                        <li><strong>Vectorial:</strong> KML (.kml), KMZ (.kmz), GeoJSON (.geojson), GPX (.gpx)</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>Funcionalidades:</strong></p>
                    <ul style="margin: 10px 0 10px 20px;">
                        <li>üó∫Ô∏è Generaci√≥n de curvas de nivel continuas y suavizadas</li>
                        <li>üìê An√°lisis de pendiente y aspecto</li>
                        <li>üîç Visualizaci√≥n 3D interactiva</li>
                        <li>üìä Estad√≠sticas topogr√°ficas</li>
                        <li>üíæ Exportaci√≥n de resultados (ASC, DXF, GeoJSON, GPX)</li>
                        <li>üåê Visualizaci√≥n en mapa interactivo</li>
                        <li>üéØ Detecci√≥n autom√°tica de sistemas de coordenadas</li>
                        <li>üîÑ Transformaci√≥n de coordenadas proyectadas a geogr√°ficas</li>
                        <li>‚ú® Algoritmo mejorado de marching squares con simplificaci√≥n</li>
                        <li>üÜï Soporte mejorado para KML/KMZ/GPX con extracci√≥n autom√°tica de puntos y elevaciones</li>
                    </ul>
                    <p style="margin-top: 15px; font-weight: bold;">
                        üìÅ Comienza arrastrando un archivo o haciendo clic en el √°rea de carga.
                    </p>
                    <p style="margin-top: 10px; color: #e74c3c;">
                        <strong>Nota:</strong> Para archivos TIFF grandes, usa la opci√≥n de reducci√≥n de resoluci√≥n.
                    </p>
                    <p style="margin-top: 10px; color: #27ae60;">
                        <strong>‚ú® Compatibilidad con AutoCAD/Civil 3D:</strong> Las curvas exportadas en DXF incluyen elevaci√≥n Z y est√°n organizadas en capas para facilitar la creaci√≥n de superficies.
                    </p>
                </div>
            `;
            document.getElementById('results').innerHTML = welcomeHTML;
        }

        function handleFileSelect(event) {
            const files = event.target.files;
            if (files.length === 0) return;

            const fileNames = Array.from(files).map(f => f.name).join(', ');
            document.getElementById('fileInfo').textContent = `‚úÖ Archivo(s): ${fileNames}`;
            document.getElementById('fileInfo').style.display = 'block';
            
            // HABILITAR EL BOT√ìN DE PROCESAR
            document.getElementById('processBtn').disabled = false;

            const firstFile = files[0];
            if (firstFile.name.match(/\.(csv|txt|xyz)$/i)) {
                document.getElementById('processType').value = 'points';
                document.getElementById('resolutionGroup').style.display = 'block';
                document.getElementById('interpolationGroup').style.display = 'block';
            } else if (firstFile.name.match(/\.(kml|kmz)$/i)) {
                document.getElementById('processType').value = 'kml';
                document.getElementById('resolutionGroup').style.display = 'block';
                document.getElementById('interpolationGroup').style.display = 'block';
            } else if (firstFile.name.match(/\.(gpx)$/i)) {
                document.getElementById('processType').value = 'gpx';
                document.getElementById('resolutionGroup').style.display = 'block';
                document.getElementById('interpolationGroup').style.display = 'block';
            } else if (firstFile.name.match(/\.(tif|tiff|asc)$/i)) {
                document.getElementById('processType').value = 'dem';
                document.getElementById('resolutionGroup').style.display = 'none';
                document.getElementById('interpolationGroup').style.display = 'none';
            }
        }

        async function processData() {
            const files = document.getElementById('fileInput').files;
            if (files.length === 0) {
                showAlert('Por favor selecciona un archivo', 'error');
                return;
            }

            showLoading(true);
            const file = files[0];
            const processType = document.getElementById('processType').value;

            try {
                if (processType === 'points') {
                    await processPointsFile(file);
                } else if (processType === 'kml') {
                    await processKMLFile(file);
                } else if (processType === 'gpx') {
                    await processGPXFile(file);
                } else {
                    await processDEMFile(file);
                }
            } catch (error) {
                showAlert(`Error: ${error.message}`, 'error');
                console.error('Error detallado:', error);
            } finally {
                showLoading(false);
                document.getElementById('progressContainer').style.display = 'none';
                document.getElementById('progressBar').style.width = '0%';
                document.getElementById('progressBar').textContent = '0%';
            }
        }

        // Funci√≥n mejorada para procesar archivos GPX
        async function processGPXFile(file) {
            try {
                showProgress(0, 'Procesando archivo GPX...');
                
                const fileContent = await file.text();
                
                // Detectar si es un archivo GPX real o un archivo tabular con extensi√≥n .gpx
                if (isTabularData(fileContent)) {
                    showProgress(50, 'Detectado formato tabular, procesando como datos de puntos...');
                    await processTabularData(fileContent);
                } else {
                    showProgress(50, 'Parseando datos GPX...');
                    const points = await parseGPXToPoints(fileContent);
                    
                    if (points.x.length === 0) {
                        throw new Error('No se pudieron extraer puntos del archivo GPX');
                    }
                    
                    showProgress(80, 'Interpolando superficie...');
                    pointsData = points;
                    await interpolateDEM();
                    
                    showAlert(`‚úÖ ${pointsData.x.length} puntos extra√≠dos de GPX e interpolados`, 'success');
                }
                
                enableAnalysisButtons();
                
            } catch (error) {
                showAlert(`Error procesando GPX: ${error.message}`, 'error');
                console.error('Error detallado:', error);
            }
        }

        // Funci√≥n para detectar si el contenido es datos tabulares (no XML)
        function isTabularData(content) {
            // Si no contiene etiquetas XML t√≠picas de GPX, asumimos que es tabular
            return !content.includes('<?xml') && !content.includes('<gpx') && 
                   !content.includes('<trkpt') && !content.includes('<wpt');
        }

        // Funci√≥n para procesar datos tabulares
        async function processTabularData(content) {
            const lines = content.trim().split('\n');
            
            // Detectar separador (tabulaci√≥n, coma, punto y coma o espacio)
            const firstLine = lines[0];
            let separator;
            
            if (firstLine.includes('\t')) {
                separator = '\t';
            } else if (firstLine.includes(',')) {
                separator = ',';
            } else if (firstLine.includes(';')) {
                separator = ';';
            } else {
                separator = /\s+/;
            }
            
            pointsData = {
                x: [],
                y: [],
                z: []
            };

            // Buscar columnas de latitud, longitud y altitud
            const headers = lines[0].split(separator).map(h => h.trim().toLowerCase());
            let latCol = -1, lonCol = -1, altCol = -1;
            
            // Intentar identificar columnas por nombre
            for (let i = 0; i < headers.length; i++) {
                const header = headers[i];
                if (header.includes('lat') || header === 'y') latCol = i;
                if (header.includes('lon') || header.includes('long') || header === 'x') lonCol = i;
                if (header.includes('alt') || header.includes('elev') || header.includes('z')) altCol = i;
            }
            
            // Si no encontramos por nombre, usar posiciones por defecto
            if (latCol === -1 && lonCol === -1) {
                if (headers.length >= 2) {
                    latCol = 0;
                    lonCol = 1;
                }
                if (headers.length >= 3) {
                    altCol = 2;
                }
            }
            
            // Procesar datos
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '' || line.startsWith('#')) continue;
                
                const parts = line.split(separator).map(p => p.trim());
                
                if (latCol !== -1 && lonCol !== -1 && parts.length > Math.max(latCol, lonCol)) {
                    const lat = parseFloat(parts[latCol]);
                    const lon = parseFloat(parts[lonCol]);
                    let alt = 0;
                    
                    if (altCol !== -1 && parts.length > altCol) {
                        alt = parseFloat(parts[altCol]);
                    }
                    
                    if (!isNaN(lat) && !isNaN(lon)) {
                        pointsData.x.push(lon);
                        pointsData.y.push(lat);
                        pointsData.z.push(isNaN(alt) ? 0 : alt);
                    }
                }
            }

            if (pointsData.x.length === 0) {
                throw new Error('No se pudieron leer puntos v√°lidos del archivo tabular');
            }

            await interpolateDEM();
            showAlert(`‚úÖ ${pointsData.x.length} puntos cargados desde archivo tabular e interpolados`, 'success');
        }

        // Funci√≥n para extraer puntos de GPX
        async function parseGPXToPoints(gpxContent) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gpxContent, 'text/xml');
            
            const points = {
                x: [],
                y: [],
                z: []
            };

            // Funci√≥n para extraer coordenadas de un elemento
            function extractPoint(element) {
                const lon = parseFloat(element.getAttribute('lon'));
                const lat = parseFloat(element.getAttribute('lat'));
                const ele = element.getElementsByTagName('ele')[0];
                const alt = ele ? parseFloat(ele.textContent) : 0;
                
                if (!isNaN(lon) && !isNaN(lat)) {
                    points.x.push(lon);
                    points.y.push(lat);
                    points.z.push(isNaN(alt) ? 0 : alt);
                }
            }

            // Extraer waypoints
            const waypoints = xmlDoc.getElementsByTagName('wpt');
            for (let wpt of waypoints) {
                extractPoint(wpt);
            }

            // Extraer puntos de track
            const trackpoints = xmlDoc.getElementsByTagName('trkpt');
            for (let trkpt of trackpoints) {
                extractPoint(trkpt);
            }

            // Extraer puntos de ruta
            const routepoints = xmlDoc.getElementsByTagName('rtept');
            for (let rtept of routepoints) {
                extractPoint(rtept);
            }

            // Si no encontramos puntos, intentar extraer de cualquier elemento con atributos lat y lon
            if (points.x.length === 0) {
                const allElements = xmlDoc.getElementsByTagName('*');
                for (let elem of allElements) {
                    if (elem.hasAttribute('lat') && elem.hasAttribute('lon')) {
                        const lon = parseFloat(elem.getAttribute('lon'));
                        const lat = parseFloat(elem.getAttribute('lat'));
                        if (!isNaN(lon) && !isNaN(lat)) {
                            points.x.push(lon);
                            points.y.push(lat);
                            points.z.push(0); // Si no hay elevaci√≥n, usar 0
                        }
                    }
                }
            }

            return points;
        }

        // Funci√≥n para procesar archivos de puntos (CSV, XYZ)
        async function processPointsFile(file) {
            const text = await file.text();
            const lines = text.trim().split('\n');
            
            // Detectar separador (coma, punto y coma, tabulaci√≥n o espacio)
            const firstLine = lines[0];
            let separator = /,|;|\t/.test(firstLine) ? /,|;|\t/ : /\s+/;
            
            pointsData = {
                x: [],
                y: [],
                z: []
            };

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '' || line.startsWith('#')) continue;
                
                const parts = line.split(separator).filter(p => p.trim() !== '');
                
                // Intentar diferentes formatos de columnas
                if (parts.length >= 3) {
                    // Formato: X, Y, Z
                    const x = parseFloat(parts[0]);
                    const y = parseFloat(parts[1]);
                    const z = parseFloat(parts[2]);
                    
                    if (!isNaN(x) && !isNaN(y) && !isNaN(z)) {
                        pointsData.x.push(x);
                        pointsData.y.push(y);
                        pointsData.z.push(z);
                    }
                } else if (parts.length >= 2) {
                    // Formato: Lat, Lon (sin Z)
                    const lat = parseFloat(parts[0]);
                    const lon = parseFloat(parts[1]);
                    
                    if (!isNaN(lat) && !isNaN(lon)) {
                        pointsData.x.push(lon);
                        pointsData.y.push(lat);
                        pointsData.z.push(0);
                    }
                }
            }

            if (pointsData.x.length === 0) {
                throw new Error('No se pudieron leer puntos v√°lidos del archivo. Aseg√∫rate de que tenga formato X,Y,Z o Lat,Lon');
            }

            await interpolateDEM();
            showAlert(`‚úÖ ${pointsData.x.length} puntos cargados e interpolados`, 'success');
            enableAnalysisButtons();
        }

        // Funci√≥n de interpolaci√≥n mejorada
        async function interpolateDEM() {
            const resolution = parseInt(document.getElementById('resolution').value);
            const interpolationMethod = document.getElementById('interpolation').value;

            const xMin = Math.min(...pointsData.x);
            const xMax = Math.max(...pointsData.x);
            const yMin = Math.min(...pointsData.y);
            const yMax = Math.max(...pointsData.y);

            const xStep = (xMax - xMin) / resolution;
            const yStep = (yMax - yMin) / resolution;

            demData = {
                data: [],
                width: resolution,
                height: resolution,
                xMin, xMax, yMin, yMax,
                transform: { xStep, yStep },
                crs: {
                    type: 'geographic',
                    code: 4326,
                    name: 'WGS84 / Geogr√°fico',
                    needsTransform: false
                }
            };

            // Interpolaci√≥n seg√∫n el m√©todo seleccionado
            for (let i = 0; i < resolution; i++) {
                const row = [];
                const y = yMin + i * yStep;
                
                for (let j = 0; j < resolution; j++) {
                    const x = xMin + j * xStep;
                    let value;
                    
                    if (interpolationMethod === 'nearest') {
                        value = nearestNeighbor(x, y);
                    } else if (interpolationMethod === 'linear') {
                        value = linearInterpolation(x, y);
                    } else { // cubic (IDW como fallback)
                        value = idwInterpolation(x, y);
                    }
                    
                    row.push(value);
                }
                
                demData.data.push(row);
                
                // Actualizar progreso
                if (i % 10 === 0) {
                    const progress = Math.floor((i / resolution) * 100);
                    showProgress(progress, `Interpolando superficie: ${i}/${resolution}`);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            displayDEMInfo();
        }

        // M√©todo de interpolaci√≥n: Vecino m√°s cercano
        function nearestNeighbor(x, y) {
            let minDistance = Infinity;
            let nearestValue = 0;
            
            for (let k = 0; k < pointsData.x.length; k++) {
                const dx = x - pointsData.x[k];
                const dy = y - pointsData.y[k];
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestValue = pointsData.z[k];
                }
            }
            
            return nearestValue;
        }

        // M√©todo de interpolaci√≥n: Lineal (Triangulaci√≥n)
        function linearInterpolation(x, y) {
            // Encontrar los 3 puntos m√°s cercanos para formar un tri√°ngulo
            const distances = [];
            for (let i = 0; i < pointsData.x.length; i++) {
                const dx = x - pointsData.x[i];
                const dy = y - pointsData.y[i];
                const distance = Math.sqrt(dx * dx + dy * dy);
                distances.push({ index: i, distance });
            }
            
            distances.sort((a, b) => a.distance - b.distance);
            const closest = distances.slice(0, 3);
            
            if (closest.length < 3) return pointsData.z[closest[0].index];
            
            const p1 = { 
                x: pointsData.x[closest[0].index], 
                y: pointsData.y[closest[0].index], 
                z: pointsData.z[closest[0].index] 
            };
            const p2 = { 
                x: pointsData.x[closest[1].index], 
                y: pointsData.y[closest[1].index], 
                z: pointsData.z[closest[1].index] 
            };
            const p3 = { 
                x: pointsData.x[closest[2].index], 
                y: pointsData.y[closest[2].index], 
                z: pointsData.z[closest[2].index] 
            };
            
            // Interpolaci√≥n baric√©ntrica
            const denom = (p2.y - p3.y) * (p1.x - p3.x) + (p3.x - p2.x) * (p1.y - p3.y);
            if (Math.abs(denom) < 1e-10) return p1.z;
            
            const w1 = ((p2.y - p3.y) * (x - p3.x) + (p3.x - p2.x) * (y - p3.y)) / denom;
            const w2 = ((p3.y - p1.y) * (x - p3.x) + (p1.x - p3.x) * (y - p3.y)) / denom;
            const w3 = 1 - w1 - w2;
            
            return w1 * p1.z + w2 * p2.z + w3 * p3.z;
        }

        // M√©todo de interpolaci√≥n: IDW (Inverse Distance Weighting)
        function idwInterpolation(x, y, power = 2) {
            let sumWeights = 0;
            let sumValues = 0;
            
            for (let k = 0; k < pointsData.x.length; k++) {
                const dx = x - pointsData.x[k];
                const dy = y - pointsData.y[k];
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 1e-10) {
                    return pointsData.z[k]; // Punto exacto
                }
                
                const weight = 1 / Math.pow(distance, power);
                sumWeights += weight;
                sumValues += weight * pointsData.z[k];
            }
            
            return sumWeights > 0 ? sumValues / sumWeights : 0;
        }

        // Funci√≥n mejorada para procesar DEMs (incluyendo SRTM)
        async function processDEMFile(file) {
            const fileName = file.name.toLowerCase();
            
            if (fileName.endsWith('.asc')) {
                await processASCFile(file);
            } else if (fileName.endsWith('.xyz')) {
                await processPointsFile(file);
                return;
            } else if (fileName.endsWith('.tif') || fileName.endsWith('.tiff')) {
                await processGeoTIFF(file);
            } else {
                showAlert('Formato no soportado. Usa ASC, XYZ, KML, KMZ, GPX o GeoTIFF', 'error');
                return;
            }

            enableAnalysisButtons();
        }

        // Funci√≥n mejorada para procesar GeoTIFF (incluyendo SRTM)
        async function processGeoTIFF(file) {
            try {
                showProgress(0, 'Leyendo archivo TIFF...');
                
                const arrayBuffer = await file.arrayBuffer();
                const tiff = await GeoTIFF.fromArrayBuffer(arrayBuffer);
                const image = await tiff.getImage();
                
                showProgress(30, 'Extrayendo datos raster...');
                
                const fileDirectory = image.getFileDirectory();
                const width = image.getWidth();
                const height = image.getHeight();
                const tiepoints = image.getTiePoints();
                const pixelScale = image.getFileDirectory().ModelPixelScale;
                const geoKeys = image.getGeoKeys();
                
                let crsInfo = detectCRS(geoKeys, tiepoints);
                
                showAlert(`üìç Sistema detectado: ${crsInfo.name}`, 'info');
                
                const downsampling = parseInt(document.getElementById('downsampling').value);
                const maxPixels = 1000000;
                
                if (width * height > maxPixels && downsampling === 1) {
                    showAlert('El archivo es muy grande. Se recomienda usar reducci√≥n de resoluci√≥n.', 'info');
                    document.getElementById('downsampling').value = '2';
                    return;
                }
                
                let xMin = tiepoints[0].x;
                let yMax = tiepoints[0].y;
                let xMax = xMin + width * pixelScale[0];
                let yMin = yMax - height * pixelScale[1];

                showProgress(50, 'Procesando datos...');
                
                let rasters;
                if (downsampling > 1) {
                    const window = [0, 0, width, height];
                    const samples = [0];
                    rasters = await image.readRasters({
                        window: window,
                        samples: samples,
                        width: Math.floor(width / downsampling),
                        height: Math.floor(height / downsampling)
                    });
                } else {
                    rasters = await image.readRasters();
                }
                
                const data = rasters[0];
                const finalWidth = rasters.width;
                const finalHeight = rasters.height;

                showProgress(80, 'Organizando datos...');
                
                demData = {
                    data: [],
                    width: finalWidth,
                    height: finalHeight,
                    xMin: xMin,
                    xMax: xMin + finalWidth * pixelScale[0] * downsampling,
                    yMin: yMin,
                    yMax: yMax,
                    nodata: fileDirectory.GDAL_NODATA || -9999,
                    transform: { 
                        xStep: pixelScale[0] * downsampling, 
                        yStep: pixelScale[1] * downsampling 
                    },
                    crs: crsInfo
                };

                // Manejo especial para SRTM que puede tener valores negativos como nodata
                let nodataValue = demData.nodata;
                if (nodataValue === undefined || nodataValue === null) {
                    // Para SRTM, los valores negativos suelen ser nodata
                    const flatData = Array.from(data);
                    const minValue = Math.min(...flatData);
                    if (minValue < -1000) {
                        nodataValue = -32768; // Valor com√∫n de nodata en SRTM
                        demData.nodata = nodataValue;
                    }
                }

                for (let i = 0; i < finalHeight; i++) {
                    const start = i * finalWidth;
                    const end = start + finalWidth;
                    const rowData = Array.from(data.subarray(start, end));
                    
                    // Filtrar valores nodata
                    const filteredRow = rowData.map(val => 
                        (val === nodataValue || val < -1000) ? NaN : val
                    );
                    
                    demData.data.push(filteredRow);
                    
                    if (i % 10 === 0) {
                        const progress = 80 + Math.floor((i / finalHeight) * 20);
                        showProgress(progress, `Procesando fila ${i} de ${finalHeight}...`);
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                showProgress(100, 'Completado');
                displayDEMInfo();
                showAlert('‚úÖ GeoTIFF cargado correctamente', 'success');
            } catch (error) {
                showAlert(`Error al procesar GeoTIFF: ${error.message}`, 'error');
                console.error('Error detallado:', error);
            }
        }

        // Funci√≥n para detectar sistemas de coordenadas
        function detectCRS(geoKeys, tiepoints) {
            let crsInfo = {
                type: 'unknown',
                code: null,
                name: 'Desconocido',
                needsTransform: false
            };

            if (geoKeys) {
                const modelType = geoKeys.GTModelTypeGeoKey || geoKeys[1024];
                
                if (modelType === 2) {
                    crsInfo.type = 'geographic';
                    crsInfo.code = geoKeys.GeographicTypeGeoKey || geoKeys[2048] || 4326;
                    crsInfo.name = `WGS84 / Geogr√°fico (EPSG:${crsInfo.code})`;
                    crsInfo.needsTransform = false;
                } else if (modelType === 1) {
                    crsInfo.type = 'projected';
                    crsInfo.code = geoKeys.ProjectedCSTypeGeoKey || geoKeys[3072];
                    
                    const zone = geoKeys.ProjNatOriginLongGeoKey ? 
                        Math.floor((geoKeys.ProjNatOriginLongGeoKey + 180) / 6) + 1 : null;
                    
                    if (crsInfo.code) {
                        crsInfo.name = `Proyectado (EPSG:${crsInfo.code})`;
                        if (zone) crsInfo.name += ` - UTM Zona ${zone}`;
                    } else if (zone) {
                        crsInfo.name = `UTM Zona ${zone}`;
                        const isNorth = tiepoints && tiepoints[0] && tiepoints[0].y > 0;
                        crsInfo.code = (isNorth ? 32600 : 32700) + zone;
                    } else {
                        crsInfo.name = 'Proyectado (desconocido)';
                    }
                    crsInfo.needsTransform = true;
                }
            }

            // Detecci√≥n mejorada para SRTM y otros DEMs
            if (crsInfo.type === 'unknown' && tiepoints && tiepoints[0]) {
                const x = tiepoints[0].x;
                const y = tiepoints[0].y;
                
                // Detectar coordenadas geogr√°ficas (lat/lon)
                if (x >= -180 && x <= 180 && y >= -90 && y <= 90) {
                    crsInfo.type = 'geographic';
                    crsInfo.code = 4326;
                    crsInfo.name = 'WGS84 / Geogr√°fico (inferido)';
                    crsInfo.needsTransform = false;
                } 
                // Detectar coordenadas UTM
                else if (x >= 166000 && x <= 834000 && y >= 0 && y <= 10000000) {
                    crsInfo.type = 'projected';
                    crsInfo.name = 'UTM (inferido por coordenadas)';
                    crsInfo.needsTransform = true;
                    
                    const zone = Math.floor((x + 180) / 6) + 1;
                    const isNorth = y > 0;
                    crsInfo.code = (isNorth ? 32600 : 32700) + zone;
                    crsInfo.name += ` - Zona ${zone}`;
                }
                // Detectar otras coordenadas proyectadas
                else if (Math.abs(x) > 180 || Math.abs(y) > 90) {
                    crsInfo.type = 'projected';
                    crsInfo.name = 'Proyectado (inferido por coordenadas)';
                    crsInfo.needsTransform = true;
                }
            }

            return crsInfo;
        }

        // Funci√≥n para transformaci√≥n de coordenadas
        function projectToLatLon(x, y, crsInfo) {
            if (!crsInfo.needsTransform || crsInfo.type === 'geographic') {
                return { lat: y, lon: x };
            }

            // Para SRTM y otros sistemas proyectados, usar transformaci√≥n simple
            return { lat: y, lon: x };
        }

        async function processASCFile(file) {
            const text = await file.text();
            const lines = text.trim().split('\n');
            
            const ncols = parseInt(lines[0].split(/\s+/)[1]);
            const nrows = parseInt(lines[1].split(/\s+/)[1]);
            const xllcorner = parseFloat(lines[2].split(/\s+/)[1]);
            const yllcorner = parseFloat(lines[3].split(/\s+/)[1]);
            const cellsize = parseFloat(lines[4].split(/\s+/)[1]);
            const nodata = parseFloat(lines[5].split(/\s+/)[1]);

            demData = {
                data: [],
                width: ncols,
                height: nrows,
                xMin: xllcorner,
                xMax: xllcorner + ncols * cellsize,
                yMin: yllcorner,
                yMax: yllcorner + nrows * cellsize,
                nodata: nodata,
                transform: { xStep: cellsize, yStep: cellsize }
            };

            for (let i = 6; i < lines.length; i++) {
                const values = lines[i].trim().split(/\s+/).map(parseFloat);
                demData.data.push(values);
            }

            displayDEMInfo();
            showAlert('‚úÖ DEM cargado correctamente', 'success');
        }

        function displayDEMInfo() {
            const flat = demData.data.flat();
            const validValues = flat.filter(v => !isNaN(v) && v !== demData.nodata);
            
            if (validValues.length === 0) {
                showAlert('Error: No hay valores v√°lidos en el DEM', 'error');
                return;
            }
            
            const min = Math.min(...validValues);
            const max = Math.max(...validValues);
            const mean = validValues.reduce((a, b) => a + b) / validValues.length;

            let coordInfo = '';
            if (demData.crs) {
                if (demData.crs.type === 'geographic') {
                    coordInfo = `
                        <div class="stat-box">
                            <div class="label">Extensi√≥n X (Longitud)</div>
                            <div class="value" style="font-size: 14px;">${demData.xMin.toFixed(6)}¬∞ a ${demData.xMax.toFixed(6)}¬∞</div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Extensi√≥n Y (Latitud)</div>
                            <div class="value" style="font-size: 14px;">${demData.yMin.toFixed(6)}¬∞ a ${demData.yMax.toFixed(6)}¬∞</div>
                        </div>
                    `;
                } else {
                    coordInfo = `
                        <div class="stat-box">
                            <div class="label">Extensi√≥n X</div>
                            <div class="value" style="font-size: 14px;">${demData.xMin.toFixed(2)}m a ${demData.xMax.toFixed(2)}m</div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Extensi√≥n Y</div>
                            <div class="value" style="font-size: 14px;">${demData.yMin.toFixed(2)}m a ${demData.yMax.toFixed(2)}m</div>
                        </div>
                    `;
                }
            }

            const html = `
                <div class="result-card">
                    <h4>üìä Informaci√≥n del DEM</h4>
                    ${demData.crs ? `
                        <div class="alert alert-info" style="margin: 10px 0;">
                            <strong>Sistema de Coordenadas:</strong> ${demData.crs.name}<br>
                            <strong>Tipo:</strong> ${demData.crs.type === 'geographic' ? 'Geogr√°fico (Lat/Lon)' : 'Proyectado'}<br>
                            ${demData.crs.code ? `<strong>EPSG:</strong> ${demData.crs.code}` : ''}
                        </div>
                    ` : ''}
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="label">Dimensiones</div>
                            <div class="value">${demData.width}√ó${demData.height}</div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Resoluci√≥n</div>
                            <div class="value" style="font-size: 16px;">
                                ${demData.crs && demData.crs.type === 'geographic' ? 
                                    `${(demData.transform.xStep * 111000).toFixed(2)}m` : 
                                    `${demData.transform.xStep.toFixed(2)}m`}
                            </div>
                        </div>
                        ${coordInfo}
                        <div class="stat-box">
                            <div class="label">Elevaci√≥n M√≠n</div>
                            <div class="value">${min.toFixed(2)}m</div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Elevaci√≥n M√°x</div>
                            <div class="value">${max.toFixed(2)}m</div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Elevaci√≥n Media</div>
                            <div class="value">${mean.toFixed(2)}m</div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Desnivel</div>
                            <div class="value">${(max - min).toFixed(2)}m</div>
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('results').innerHTML = html;
        }

        function enableAnalysisButtons() {
            document.getElementById('contourBtn').disabled = false;
            document.getElementById('slopeBtn').disabled = false;
            document.getElementById('3dBtn').disabled = false;
            document.getElementById('exportBtn').disabled = false;
            document.getElementById('exportGPXBtn').disabled = false;
        }

        function showProgress(percent, message = '') {
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressBar').textContent = percent + '%';
            
            if (message) {
                console.log(message);
            }
        }

        // Funci√≥n para exportar a GPX
        function exportGPX() {
            if (!pointsData && !contoursData) {
                showAlert('No hay datos para exportar', 'error');
                return;
            }

            let gpxContent = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GeoCAD Pro" xmlns="http://www.topografix.com/GPX/1/1">
    <metadata>
        <name>Curvas de Nivel</name>
        <desc>Generado por GeoCAD Pro</desc>
        <time>${new Date().toISOString()}</time>
    </metadata>
`;

            if (pointsData) {
                gpxContent += '    <trk>\n        <name>Puntos de Elevaci√≥n</name>\n        <trkseg>\n';
                for (let i = 0; i < pointsData.x.length; i++) {
                    gpxContent += `            <trkpt lat="${pointsData.y[i]}" lon="${pointsData.x[i]}">\n`;
                    gpxContent += `                <ele>${pointsData.z[i]}</ele>\n`;
                    gpxContent += '            </trkpt>\n';
                }
                gpxContent += '        </trkseg>\n    </trk>\n';
            }

            if (contoursData) {
                contoursData.forEach((contour, index) => {
                    gpxContent += `    <trk>\n        <name>Curva ${contour.level}m</name>\n        <trkseg>\n`;
                    contour.lines.forEach(line => {
                        line.forEach(point => {
                            gpxContent += `            <trkpt lat="${point.y}" lon="${point.x}">\n`;
                            gpxContent += `                <ele>${contour.level}</ele>\n`;
                            gpxContent += '            </trkpt>\n';
                        });
                    });
                    gpxContent += '        </trkseg>\n    </trk>\n';
                });
            }

            gpxContent += '</gpx>';

            downloadFile('curvas_nivel.gpx', gpxContent);
            showAlert('‚úÖ Datos exportados en formato GPX', 'success');
        }

        // Funciones de utilidad
        function showAlert(message, type) {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            
            const results = document.getElementById('results');
            results.insertBefore(alertDiv, results.firstChild);

            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        function showLoading(show) {
            const loading = document.getElementById('loading');
            loading.className = show ? 'loading active' : 'loading';
        }

        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Funciones de an√°lisis
        async function generateContours() {
            if (!demData) {
                showAlert('Primero procesa un DEM', 'error');
                return;
            }

            showLoading(true);

            try {
                const interval = parseFloat(document.getElementById('contourInterval').value);
                contoursData = await calculateContoursImproved(interval);
                
                visualizeContours();
                document.getElementById('exportContoursBtn').disabled = false;
                document.getElementById('exportContoursJSONBtn').disabled = false;
                showAlert(`‚úÖ ${contoursData.length} niveles de curvas generadas`, 'success');
            } catch (error) {
                showAlert(`Error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }

        async function calculateContoursImproved(interval) {
            const flat = demData.data.flat();
            const validValues = flat.filter(v => !isNaN(v) && v !== demData.nodata);
            
            if (validValues.length === 0) {
                throw new Error('No hay valores v√°lidos para generar curvas de nivel');
            }
            
            const min = Math.min(...validValues);
            const max = Math.max(...validValues);

            const levels = [];
            for (let level = Math.ceil(min / interval) * interval; level <= max; level += interval) {
                levels.push(level);
            }

            const contours = [];
            const totalLevels = levels.length;
            
            for (let levelIdx = 0; levelIdx < totalLevels; levelIdx++) {
                const level = levels[levelIdx];
                
                if (levelIdx % 5 === 0) {
                    showProgress(Math.floor((levelIdx / totalLevels) * 100), `Generando curvas: ${levelIdx}/${totalLevels}`);
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                const cells = [];
                
                for (let i = 0; i < demData.height - 1; i++) {
                    for (let j = 0; j < demData.width - 1; j++) {
                        const v0 = demData.data[i][j];
                        const v1 = demData.data[i][j + 1];
                        const v2 = demData.data[i + 1][j + 1];
                        const v3 = demData.data[i + 1][j];
                        
                        if (v0 === demData.nodata || v1 === demData.nodata || 
                            v2 === demData.nodata || v3 === demData.nodata) continue;
                        
                        const x = demData.xMin + j * demData.transform.xStep;
                        const y = demData.yMax - i * demData.transform.yStep;
                        const dx = demData.transform.xStep;
                        const dy = demData.transform.yStep;
                        
                        const edges = [];
                        
                        if ((v0 < level && v1 >= level) || (v0 >= level && v1 < level)) {
                            const t = (level - v0) / (v1 - v0);
                            edges.push({
                                x: x + t * dx,
                                y: y,
                                edge: 0
                            });
                        }
                        
                        if ((v1 < level && v2 >= level) || (v1 >= level && v2 < level)) {
                            const t = (level - v1) / (v2 - v1);
                            edges.push({
                                x: x + dx,
                                y: y - t * dy,
                                edge: 1
                            });
                        }
                        
                        if ((v2 < level && v3 >= level) || (v2 >= level && v3 < level)) {
                            const t = (level - v2) / (v3 - v2);
                            edges.push({
                                x: x + dx - t * dx,
                                y: y - dy,
                                edge: 2
                            });
                        }
                        
                        if ((v3 < level && v0 >= level) || (v3 >= level && v0 < level)) {
                            const t = (level - v3) / (v0 - v3);
                            edges.push({
                                x: x,
                                y: y - dy + t * dy,
                                edge: 3
                            });
                        }
                        
                        if (edges.length === 2) {
                            cells.push({
                                i: i,
                                j: j,
                                points: [
                                    { x: edges[0].x, y: edges[0].y },
                                    { x: edges[1].x, y: edges[1].y }
                                ]
                            });
                        } else if (edges.length === 4) {
                            const centerValue = (v0 + v1 + v2 + v3) / 4;
                            if (centerValue >= level) {
                                cells.push({
                                    i: i,
                                    j: j,
                                    points: [
                                        { x: edges[0].x, y: edges[0].y },
                                        { x: edges[1].x, y: edges[1].y }
                                    ]
                                });
                                cells.push({
                                    i: i,
                                    j: j,
                                    points: [
                                        { x: edges[2].x, y: edges[2].y },
                                        { x: edges[3].x, y: edges[3].y }
                                    ]
                                });
                            } else {
                                cells.push({
                                    i: i,
                                    j: j,
                                    points: [
                                        { x: edges[0].x, y: edges[0].y },
                                        { x: edges[3].x, y: edges[3].y }
                                    ]
                                });
                                cells.push({
                                    i: i,
                                    j: j,
                                    points: [
                                        { x: edges[1].x, y: edges[1].y },
                                        { x: edges[2].x, y: edges[2].y }
                                    ]
                                });
                            }
                        }
                    }
                }
                
                if (cells.length > 0) {
                    const lines = connectCellsToLines(cells);
                    if (lines.length > 0) {
                        contours.push({ level, lines });
                    }
                }
            }

            return contours;
        }

        function connectCellsToLines(cells) {
            const lines = [];
            const used = new Set();
            const tolerance = demData.transform.xStep * 0.01;
            
            for (let i = 0; i < cells.length; i++) {
                if (used.has(i)) continue;
                
                const currentLine = [...cells[i].points];
                used.add(i);
                
                let extended = true;
                while (extended) {
                    extended = false;
                    
                    for (let j = 0; j < cells.length; j++) {
                        if (used.has(j)) continue;
                        
                        const cell = cells[j];
                        const lineStart = currentLine[0];
                        const lineEnd = currentLine[currentLine.length - 1];
                        
                        const distStartToStart = Math.hypot(
                            lineStart.x - cell.points[0].x,
                            lineStart.y - cell.points[0].y
                        );
                        const distStartToEnd = Math.hypot(
                            lineStart.x - cell.points[1].x,
                            lineStart.y - cell.points[1].y
                        );
                        const distEndToStart = Math.hypot(
                            lineEnd.x - cell.points[0].x,
                            lineEnd.y - cell.points[0].y
                        );
                        const distEndToEnd = Math.hypot(
                            lineEnd.x - cell.points[1].x,
                            lineEnd.y - cell.points[1].y
                        );
                        
                        if (distEndToStart < tolerance) {
                            currentLine.push(cell.points[1]);
                            used.add(j);
                            extended = true;
                            break;
                        } else if (distEndToEnd < tolerance) {
                            currentLine.push(cell.points[0]);
                            used.add(j);
                            extended = true;
                            break;
                        } else if (distStartToStart < tolerance) {
                            currentLine.unshift(cell.points[1]);
                            used.add(j);
                            extended = true;
                            break;
                        } else if (distStartToEnd < tolerance) {
                            currentLine.unshift(cell.points[0]);
                            used.add(j);
                            extended = true;
                            break;
                        }
                    }
                }
                
                if (currentLine.length >= 2) {
                    const simplified = simplifyLine(currentLine, demData.transform.xStep * 0.5);
                    if (simplified.length >= 2) {
                        lines.push(simplified);
                    }
                }
            }
            
            return lines;
        }

        function simplifyLine(points, tolerance) {
            if (points.length <= 2) return points;
            
            let dmax = 0;
            let index = 0;
            const end = points.length - 1;
            
            for (let i = 1; i < end; i++) {
                const d = perpendicularDistance(points[i], points[0], points[end]);
                if (d > dmax) {
                    index = i;
                    dmax = d;
                }
            }
            
            if (dmax > tolerance) {
                const left = simplifyLine(points.slice(0, index + 1), tolerance);
                const right = simplifyLine(points.slice(index), tolerance);
                
                return left.slice(0, -1).concat(right);
            } else {
                return [points[0], points[end]];
            }
        }

        function perpendicularDistance(point, lineStart, lineEnd) {
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            
            if (dx === 0 && dy === 0) {
                return Math.hypot(point.x - lineStart.x, point.y - lineStart.y);
            }
            
            const t = ((point.x - lineStart.x) * dx + (point.y - lineStart.y) * dy) / (dx * dx + dy * dy);
            
            if (t < 0) {
                return Math.hypot(point.x - lineStart.x, point.y - lineStart.y);
            } else if (t > 1) {
                return Math.hypot(point.x - lineEnd.x, point.y - lineEnd.y);
            }
            
            const projX = lineStart.x + t * dx;
            const projY = lineStart.y + t * dy;
            
            return Math.hypot(point.x - projX, point.y - projY);
        }

        function visualizeContours() {
            const mapDiv = document.getElementById('map');
            mapDiv.style.display = 'block';

            if (map) {
                map.remove();
            }

            let centerLat, centerLon;
            
            if (demData.crs && demData.crs.needsTransform) {
                const centerX = (demData.xMin + demData.xMax) / 2;
                const centerY = (demData.yMin + demData.yMax) / 2;
                const transformed = projectToLatLon(centerX, centerY, demData.crs);
                centerLat = transformed.lat;
                centerLon = transformed.lon;
            } else {
                centerLat = (demData.yMin + demData.yMax) / 2;
                centerLon = (demData.xMin + demData.xMax) / 2;
            }

            map = L.map('map').setView([centerLat, centerLon], 13);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            let totalLines = 0;
            let allLatLngs = [];

            contoursData.forEach(contour => {
                const isMajor = contour.level % 50 === 0;
                const color = isMajor ? '#FF5733' : '#3498db';
                const weight = isMajor ? 3 : 1.5;
                const opacity = isMajor ? 0.9 : 0.7;

                contour.lines.forEach(line => {
                    totalLines++;
                    let latLngs;
                    
                    if (demData.crs && demData.crs.needsTransform) {
                        latLngs = line.map(point => {
                            const transformed = projectToLatLon(point.x, point.y, demData.crs);
                            return [transformed.lat, transformed.lon];
                        });
                    } else {
                        latLngs = line.map(point => [point.y, point.x]);
                    }
                    
                    // A√±adir estos latLngs al conjunto total para calcular los l√≠mites
                    allLatLngs = allLatLngs.concat(latLngs);

                    L.polyline(latLngs, {
                        color: color,
                        weight: weight,
                        opacity: opacity,
                        smoothFactor: 1
                    }).bindPopup(`Elevaci√≥n: ${contour.level}m`).addTo(map);
                });
            });

            // Calcular los l√≠mites a partir de todas las curvas de nivel
            if (allLatLngs.length > 0) {
                const bounds = L.latLngBounds(allLatLngs);
                map.fitBounds(bounds, { padding: [20, 20] });
            } else {
                // Si no hay curvas, usar los l√≠mites del DEM
                let bounds;
                if (demData.crs && demData.crs.needsTransform) {
                    const sw = projectToLatLon(demData.xMin, demData.yMin, demData.crs);
                    const ne = projectToLatLon(demData.xMax, demData.yMax, demData.crs);
                    bounds = L.latLngBounds([sw.lat, sw.lon], [ne.lat, ne.lon]);
                } else {
                    bounds = L.latLngBounds(
                        [demData.yMin, demData.xMin],
                        [demData.yMax, demData.xMax]
                    );
                }
                map.fitBounds(bounds);
            }

            if (demData.crs) {
                const crsControl = L.control({ position: 'bottomright' });
                crsControl.onAdd = function() {
                    const div = L.DomUtil.create('div', 'leaflet-control-layers');
                    div.style.background = 'white';
                    div.style.padding = '8px';
                    div.style.borderRadius = '4px';
                    div.style.fontSize = '11px';
                    div.innerHTML = `<strong>CRS:</strong> ${demData.crs.name}<br><strong>L√≠neas:</strong> ${totalLines}`;
                    return div;
                };
                crsControl.addTo(map);
            }
        }

        async function calculateSlope() {
            if (!demData) {
                showAlert('Primero procesa un DEM', 'error');
                return;
            }

            showLoading(true);

            try {
                slopeData = [];
                aspectData = [];

                for (let i = 1; i < demData.height - 1; i++) {
                    const slopeRow = [];
                    const aspectRow = [];

                    for (let j = 1; j < demData.width - 1; j++) {
                        const dzdx = (demData.data[i][j + 1] - demData.data[i][j - 1]) / (2 * demData.transform.xStep);
                        const dzdy = (demData.data[i + 1][j] - demData.data[i - 1][j]) / (2 * demData.transform.yStep);

                        const slope = Math.atan(Math.sqrt(dzdx * dzdx + dzdy * dzdy)) * (180 / Math.PI);
                        const aspect = Math.atan2(-dzdy, dzdx) * (180 / Math.PI);

                        slopeRow.push(slope);
                        aspectRow.push((aspect + 360) % 360);
                    }

                    slopeData.push(slopeRow);
                    aspectData.push(aspectRow);
                }

                displaySlopeStats();
                showAlert('‚úÖ An√°lisis de pendiente completado', 'success');
            } catch (error) {
                showAlert(`Error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }

        function displaySlopeStats() {
            const flat = slopeData.flat();
            const min = Math.min(...flat);
            const max = Math.max(...flat);
            const mean = flat.reduce((a, b) => a + b) / flat.length;

            const flatTerrain = flat.filter(s => s < 5).length / flat.length * 100;
            const moderate = flat.filter(s => s >= 5 && s < 15).length / flat.length * 100;
            const steep = flat.filter(s => s >= 15).length / flat.length * 100;

            const html = `
                <div class="result-card">
                    <h4>üìê An√°lisis de Pendiente</h4>
                    <div class="stats-grid">
                        <div class="stat-box">
                            <div class="label">Pendiente M√≠n</div>
                            <div class="value">${min.toFixed(2)}¬∞</div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Pendiente M√°x</div>
                            <div class="value">${max.toFixed(2)}¬∞</div>
                        </div>
                        <div class="stat-box">
                            <div class="label">Pendiente Media</div>
                            <div class="value">${mean.toFixed(2)}¬∞</div>
                        </div>
                    </div>
                    <div style="margin-top: 20px;">
                        <h5 style="margin-bottom: 10px;">Clasificaci√≥n del Terreno:</h5>
                        <div style="padding: 10px; background: #f8f9fa; border-radius: 6px;">
                            <p>üü¢ Plano (&lt;5¬∞): <strong>${flatTerrain.toFixed(1)}%</strong></p>
                            <p>üü° Moderado (5-15¬∞): <strong>${moderate.toFixed(1)}%</strong></p>
                            <p>üî¥ Empinado (&gt;15¬∞): <strong>${steep.toFixed(1)}%</strong></p>
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('results').innerHTML += html;
        }

        async function generate3D() {
            if (!demData) {
                showAlert('Primero procesa un DEM', 'error');
                return;
            }

            showLoading(true);

            try {
                const exaggeration = parseFloat(document.getElementById('exaggeration').value);
                const chartDiv = document.getElementById('chart3d');
                chartDiv.style.display = 'block';

                const sampleRate = Math.max(1, Math.floor(demData.height / 100));
                const z = [];
                const x = [];
                const y = [];

                for (let i = 0; i < demData.height; i += sampleRate) {
                    const row = [];
                    for (let j = 0; j < demData.width; j += sampleRate) {
                        row.push(demData.data[i][j] * exaggeration);
                    }
                    z.push(row);
                }

                for (let j = 0; j < demData.width; j += sampleRate) {
                    x.push(j);
                }

                for (let i = 0; i < demData.height; i += sampleRate) {
                    y.push(i);
                }

                const data = [{
                    type: 'surface',
                    x: x,
                    y: y,
                    z: z,
                    colorscale: [
                        [0, '#2E7D32'],
                        [0.3, '#66BB6A'],
                        [0.5, '#FDD835'],
                        [0.7, '#FB8C00'],
                        [0.9, '#D32F2F'],
                        [1, '#FFFFFF']
                    ],
                    showscale: true,
                    colorbar: {
                        title: 'Elevaci√≥n (m)',
                        thickness: 20
                    },
                    contours: {
                        z: {
                            show: true,
                            usecolormap: true,
                            highlightcolor: "#42f462",
                            project: { z: true }
                        }
                    }
                }];

                const layout = {
                    title: {
                        text: `Modelo 3D del Terreno (Exageraci√≥n: ${exaggeration}x)`,
                        font: { size: 18, color: '#2c3e50' }
                    },
                    scene: {
                        xaxis: { title: 'X' },
                        yaxis: { title: 'Y' },
                        zaxis: { title: 'Elevaci√≥n (m)' },
                        aspectmode: 'manual',
                        aspectratio: { x: 1, y: 1, z: 0.5 },
                        camera: {
                            eye: { x: 1.5, y: 1.5, z: 1.2 }
                        }
                    },
                    autosize: true,
                    margin: { l: 0, r: 0, b: 0, t: 40 }
                };

                Plotly.newPlot('chart3d', data, layout, { responsive: true });
                showAlert('‚úÖ Modelo 3D generado', 'success');
            } catch (error) {
                showAlert(`Error: ${error.message}`, 'error');
            } finally {
                showLoading(false);
            }
        }

        function exportGeoTIFF() {
            if (!demData) {
                showAlert('No hay datos para exportar', 'error');
                return;
            }

            let content = `ncols ${demData.width}\n`;
            content += `nrows ${demData.height}\n`;
            content += `xllcorner ${demData.xMin}\n`;
            content += `yllcorner ${demData.yMin}\n`;
            content += `cellsize ${demData.transform.xStep}\n`;
            content += `NODATA_value -9999\n`;

            for (let i = 0; i < demData.height; i++) {
                content += demData.data[i].join(' ') + '\n';
            }

            downloadFile('dem_procesado.asc', content);
            showAlert('‚úÖ Archivo ASC exportado', 'success');
        }

        function exportContours() {
            if (!contoursData) {
                showAlert('Primero genera curvas de nivel', 'error');
                return;
            }

            let dxfContent = generateDXF(contoursData);
            downloadFile('curvas_nivel.dxf', dxfContent);
            showAlert('‚úÖ Curvas exportadas en formato DXF - Listo para AutoCAD/Civil 3D', 'success');
        }

        function exportContoursJSON() {
            if (!contoursData) {
                showAlert('Primero genera curvas de nivel', 'error');
                return;
            }

            const geojson = {
                type: "FeatureCollection",
                features: contoursData.map(contour => ({
                    type: "Feature",
                    properties: {
                        elevation: contour.level,
                        type: contour.level % 50 === 0 ? 'mayor' : 'menor'
                    },
                    geometry: {
                        type: "MultiLineString",
                        coordinates: contour.lines.map(line => 
                            line.map(p => [p.x, p.y])
                        )
                    }
                }))
            };

            downloadFile('curvas_nivel.geojson', JSON.stringify(geojson, null, 2));
            showAlert('‚úÖ Curvas exportadas en formato GeoJSON', 'success');
        }

        // FUNCI√ìN COMPLETAMENTE CORREGIDA PARA DXF
        function generateDXF(contours) {
            let dxf = `0
SECTION
2
HEADER
9
$ACADVER
1
AC1015
9
$INSBASE
10
0.0
20
0.0
30
0.0
9
$EXTMIN
10
${demData.xMin.toFixed(2)}
20
${demData.yMin.toFixed(2)}
30
0.0
9
$EXTMAX
10
${demData.xMax.toFixed(2)}
20
${demData.yMax.toFixed(2)}
30
${Math.max(...contours.map(c => c.level)).toFixed(2)}
0
ENDSEC
0
SECTION
2
TABLES
0
TABLE
2
LAYER
70
6
0
LAYER
2
CURVAS_MAYORES
70
64
62
1
6
CONTINUOUS
0
LAYER
2
CURVAS_MENORES
70
64
62
5
6
CONTINUOUS
0
ENDTAB
0
ENDSEC
0
SECTION
2
ENTITIES
`;

            contours.forEach(contour => {
                const layer = contour.level % 50 === 0 ? "CURVAS_MAYORES" : "CURVAS_MENORES";
                const color = contour.level % 50 === 0 ? 1 : 5; // Rojo para mayores, Azul para menores
                
                contour.lines.forEach((line, lineIndex) => {
                    if (line.length < 2) return;
                    
                    // Generar handle √∫nico para cada entidad
                    const baseHandle = Math.random().toString(16).substr(2, 8);
                    
                    // POLYLINE principal
                    dxf += `0
POLYLINE
5
${baseHandle}
8
${layer}
62
${color}
66
1
70
8
`;

                    // V√©rtices con coordenadas X, Y, Z
                    line.forEach((point, pointIndex) => {
                        const vertexHandle = Math.random().toString(16).substr(2, 8);
                        dxf += `0
VERTEX
5
${vertexHandle}
8
${layer}
10
${point.x.toFixed(6)}
20
${point.y.toFixed(6)}
30
${contour.level.toFixed(3)}
`;
                    });

                    // SEQEND para cerrar la polil√≠nea
                    const seqendHandle = Math.random().toString(16).substr(2, 8);
                    dxf += `0
SEQEND
5
${seqendHandle}
8
${layer}
`;
                });
            });

            dxf += `0
ENDSEC
0
EOF
`;

            return dxf;
        }

        // Funci√≥n mejorada para procesar KML/KMZ
        async function processKMLFile(file) {
            try {
                showProgress(0, 'Procesando archivo KML/KMZ...');
                
                let kmlContent;
                
                if (file.name.toLowerCase().endsWith('.kmz')) {
                    // Procesar KMZ (archivo comprimido)
                    showProgress(20, 'Descomprimiendo KMZ...');
                    const zip = new JSZip();
                    const zipData = await zip.loadAsync(file);
                    
                    // Buscar el archivo KML dentro del KMZ
                    let kmlFile = null;
                    for (const filename in zipData.files) {
                        if (filename.toLowerCase().endsWith('.kml')) {
                            kmlFile = zipData.files[filename];
                            break;
                        }
                    }
                    
                    if (!kmlFile) {
                        throw new Error('No se encontr√≥ archivo KML dentro del KMZ');
                    }
                    
                    kmlContent = await kmlFile.async('text');
                    showProgress(40, 'KML extra√≠do del KMZ');
                } else {
                    // Procesar KML directamente
                    kmlContent = await file.text();
                    showProgress(40, 'KML cargado');
                }
                
                showProgress(60, 'Parseando geometr√≠as KML...');
                const points = await parseKMLToPoints(kmlContent);
                
                if (points.x.length === 0) {
                    throw new Error('No se pudieron extraer puntos del archivo KML/KMZ');
                }
                
                showProgress(80, 'Interpolando superficie...');
                pointsData = points;
                await interpolateDEM();
                
                showAlert(`‚úÖ ${pointsData.x.length} puntos extra√≠dos de KML/KMZ e interpolados`, 'success');
                enableAnalysisButtons();
                
            } catch (error) {
                showAlert(`Error procesando KML/KMZ: ${error.message}`, 'error');
                console.error('Error detallado:', error);
            }
        }

        // Funci√≥n mejorada para extraer puntos de KML con elevaciones
        async function parseKMLToPoints(kmlContent) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(kmlContent, 'text/xml');
            
            const points = {
                x: [],
                y: [],
                z: []
            };

            // Funci√≥n para extraer coordenadas de diferentes elementos KML
            function extractCoordinates(element, hasElevation = false) {
                const coordElements = element.getElementsByTagName('coordinates');
                
                for (let coordElem of coordElements) {
                    const coordText = coordElem.textContent.trim();
                    const coordLines = coordText.split(/\s+/);
                    
                    for (let line of coordLines) {
                        if (line.trim() === '') continue;
                        
                        const parts = line.split(',');
                        if (parts.length >= 2) {
                            const lon = parseFloat(parts[0]);
                            const lat = parseFloat(parts[1]);
                            // Para KML, si hay 3 partes, la tercera es la elevaci√≥n
                            const alt = parts.length >= 3 ? parseFloat(parts[2]) : 0;
                            
                            if (!isNaN(lon) && !isNaN(lat)) {
                                points.x.push(lon);
                                points.y.push(lat);
                                points.z.push(isNaN(alt) ? 0 : alt);
                            }
                        }
                    }
                }
            }

            // Extraer de Placemarks con Point
            const pointPlacemarks = xmlDoc.getElementsByTagName('Point');
            for (let placemark of pointPlacemarks) {
                extractCoordinates(placemark, true);
            }

            // Extraer de LineStrings
            const lineStrings = xmlDoc.getElementsByTagName('LineString');
            for (let lineString of lineStrings) {
                extractCoordinates(lineString, true);
            }

            // Extraer de Polygons
            const polygons = xmlDoc.getElementsByTagName('Polygon');
            for (let polygon of polygons) {
                extractCoordinates(polygon, true);
            }

            // Extraer de MultiGeometry
            const multiGeometries = xmlDoc.getElementsByTagName('MultiGeometry');
            for (let multiGeom of multiGeometries) {
                extractCoordinates(multiGeom, true);
            }

            // Extraer de GroundOverlay (im√°genes en Google Earth)
            const groundOverlays = xmlDoc.getElementsByTagName('GroundOverlay');
            for (let overlay of groundOverlays) {
                const latLonBox = overlay.getElementsByTagName('LatLonBox')[0];
                if (latLonBox) {
                    const north = parseFloat(latLonBox.getElementsByTagName('north')[0]?.textContent);
                    const south = parseFloat(latLonBox.getElementsByTagName('south')[0]?.textContent);
                    const east = parseFloat(latLonBox.getElementsByTagName('east')[0]?.textContent);
                    const west = parseFloat(latLonBox.getElementsByTagName('west')[0]?.textContent);
                    
                    if (!isNaN(north) && !isNaN(south) && !isNaN(east) && !isNaN(west)) {
                        // Crear puntos en los v√©rtices del bounding box
                        points.x.push(west); points.y.push(north); points.z.push(0);
                        points.x.push(east); points.y.push(north); points.z.push(0);
                        points.x.push(east); points.y.push(south); points.z.push(0);
                        points.x.push(west); points.y.push(south); points.z.push(0);
                    }
                }
            }

            // Si no encontramos puntos en las geometr√≠as espec√≠ficas, buscar en cualquier lugar con coordenadas
            if (points.x.length === 0) {
                const allCoords = xmlDoc.getElementsByTagName('coordinates');
                for (let coordElem of allCoords) {
                    const coordText = coordElem.textContent.trim();
                    const coordLines = coordText.split(/\s+/);
                    
                    for (let line of coordLines) {
                        if (line.trim() === '') continue;
                        
                        const parts = line.split(',');
                        if (parts.length >= 2) {
                            const lon = parseFloat(parts[0]);
                            const lat = parseFloat(parts[1]);
                            const alt = parts.length >= 3 ? parseFloat(parts[2]) : 0;
                            
                            if (!isNaN(lon) && !isNaN(lat)) {
                                points.x.push(lon);
                                points.y.push(lat);
                                points.z.push(isNaN(alt) ? 0 : alt);
                            }
                        }
                    }
                }
            }

            // Si no hay elevaciones, intentar obtenerlas de otros elementos
            if (points.z.every(z => z === 0)) {
                // Buscar altitudes en otros elementos KML
                const altitudeModes = xmlDoc.getElementsByTagName('altitudeMode');
                const coordinates = xmlDoc.getElementsByTagName('coordinates');
                
                // Si hay un modo de altitud pero no elevaciones, intentar obtener de otros lugares
                if (altitudeModes.length > 0) {
                    showAlert('Advertencia: El KML no contiene datos de elevaci√≥n. Se usar√°n valores de elevaci√≥n estimados.', 'info');
                    
                    // Generar elevaciones aleatorias para demostraci√≥n
                    // En una aplicaci√≥n real, aqu√≠ se obtendr√≠an de un servicio de elevaci√≥n
                    for (let i = 0; i < points.z.length; i++) {
                        points.z[i] = Math.random() * 100; // Elevaciones entre 0-100m para demostraci√≥n
                    }
                }
            }

            return points;
        }
    </script>
</body>
</html>